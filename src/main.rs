use leptos::prelude::*;
use leptos_router::components::*;
use leptos_router::path;
use leptos_router::hooks::use_params_map;
use serde::{Deserialize, Serialize};
use image::ImageEncoder;

/// Tanka poem with music pairing metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Tanka {
    pub top_flavor: String,
    pub qr_link: String,
    pub art_link: String,
    #[serde(default)]
    pub bandcamp_embed: Option<String>,
    #[serde(default)]
    pub bandcamp_embed_isprivate: bool,
    pub recommended_music_pairing: MusicPairing,
    pub tanka: TankaVerses,
    pub tankadesc: String,
    #[serde(default)]
    pub tastingnotes: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MusicPairing {
    pub track: String,
    pub artist: String,
    pub album: String,
    pub volume_level: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TankaVerses {
    #[serde(rename = "1")]
    pub v1: String,
    #[serde(rename = "2")]
    pub v2: String,
    #[serde(rename = "3")]
    pub v3: String,
    #[serde(rename = "4")]
    pub v4: String,
    #[serde(rename = "5")]
    pub v5: String,
}

impl TankaVerses {
    pub fn as_vec(&self) -> Vec<&str> {
        vec![&self.v1, &self.v2, &self.v3, &self.v4, &self.v5]
    }
}

/// A tanka with its slug (URL-safe name)
#[derive(Debug, Clone)]
pub struct TankaEntry {
    pub slug: String,
    pub filename: String,
    pub tanka: Tanka,
}

/// Generate QR code as base64 PNG data URI
fn generate_qr_data_uri(url: &str) -> String {
    use qrcode::QrCode;
    use image::Luma;
    use base64::Engine;

    let code = match QrCode::new(url.as_bytes()) {
        Ok(c) => c,
        Err(_) => return String::new(),
    };

    let image = code.render::<Luma<u8>>()
        .min_dimensions(128, 128)
        .build();

    let mut png_bytes: Vec<u8> = Vec::new();
    let encoder = image::codecs::png::PngEncoder::new(&mut png_bytes);
    if encoder.write_image(
        image.as_raw(),
        image.width(),
        image.height(),
        image::ExtendedColorType::L8,
    ).is_err() {
        return String::new();
    }

    let b64 = base64::engine::general_purpose::STANDARD.encode(&png_bytes);
    format!("data:image/png;base64,{}", b64)
}

/// Load tanka from YAML string
fn load_tanka(yaml: &str) -> Option<Tanka> {
    serde_yaml::from_str(yaml).ok()
}

/// Convert filename to URL slug
fn slugify(name: &str) -> String {
    name.to_lowercase()
        .replace(' ', "-")
        .replace(".tanka.yml", "")
        .replace(".yml", "")
}

// Auto-generated by build.rs - scans content/ for tankas
include!(concat!(env!("OUT_DIR"), "/tankas_generated.rs"));

/// Index page with ls-style listing
#[component]
fn IndexPage() -> impl IntoView {
    let tankas = all_tankas();

    view! {
        <div class="page">
            <div class="terminal">
                <div class="prompt">"$ ls -la content/*.yml"</div>
                <div class="ls-output">
                    <div class="ls-header">"total "{tankas.len()}</div>
                    {tankas.into_iter().map(|entry| {
                        let slug = entry.slug.clone();
                        view! {
                            <a class="ls-row" href={format!("/tanka/{}", slug)}>
                                <span class="ls-perms">"-rw-r--r--"</span>
                                <span class="ls-user">"henry"</span>
                                <span class="ls-date">"2026-01-24"</span>
                                <span class="ls-name">{entry.filename}</span>
                            </a>
                        }
                    }).collect_view()}
                </div>
            </div>
        </div>
    }
}

/// Single tanka page component
#[component]
fn TankaPageView() -> impl IntoView {
    let params = use_params_map();
    let tankas = all_tankas();

    let slug = move || params.read().get("slug").unwrap_or_default();

    let current_idx = {
        let s = slug();
        tankas.iter().position(|t| t.slug == s)
    };

    let entry = current_idx.and_then(|i| tankas.get(i).cloned());

    match entry {
        Some(entry) => {
            let prev_slug = current_idx
                .filter(|&i| i > 0)
                .map(|i| tankas[i - 1].slug.clone());
            let next_slug = current_idx
                .filter(|&i| i < tankas.len() - 1)
                .map(|i| tankas[i + 1].slug.clone());

            let tanka = entry.tanka;
            let qr_src = generate_qr_data_uri(&tanka.qr_link);
            let verses = tanka.tanka.as_vec();

            view! {
                <div class="page">
                    <div class="tanka-header">
                        {tanka.top_flavor}
                    </div>

                    <a class="media-row" href={tanka.qr_link.clone()} target="_blank" rel="noopener">
                        <div class="qr-code">
                            <img src={qr_src} alt="Album QR code" />
                        </div>

                        <div class="album-art">
                            <img src={tanka.art_link.clone()} alt="Album art" />
                        </div>

                        <div class="pairing">
                            <span class="track">{tanka.recommended_music_pairing.track.clone()}</span>
                            " by "
                            <span class="artist">{tanka.recommended_music_pairing.artist.clone()}</span>
                            " at "
                            <span class="volume">{tanka.recommended_music_pairing.volume_level.clone()}</span>
                        </div>
                    </a>

                    <div class="bandcamp-player">
                        {if tanka.bandcamp_embed_isprivate {
                            view! {
                                <div class="private-notice">"album is private - visit link to listen"</div>
                            }.into_any()
                        } else if let Some(embed_url) = tanka.bandcamp_embed.clone() {
                            view! {
                                <iframe src={embed_url}></iframe>
                            }.into_any()
                        } else {
                            view! { <></> }.into_any()
                        }}
                    </div>

                    <div class="tanka-body">
                        {verses.into_iter().map(|v| view! {
                            <div class="tanka-verse">{v.to_string()}</div>
                        }).collect_view()}
                    </div>

                    <div class="commentary">
                        <p class="about-tanka">{tanka.tankadesc}</p>
                        {tanka.tastingnotes.map(|notes| view! {
                            <p class="about-song">{notes}</p>
                        })}
                    </div>

                    <nav class="tanka-nav">
                        <div class="nav-prev">
                            {prev_slug.map(|s| view! {
                                <a href={format!("/tanka/{}", s)}>"< prev"</a>
                            })}
                        </div>
                        <div class="nav-index">
                            <a href="/">"[ls]"</a>
                        </div>
                        <div class="nav-next">
                            {next_slug.map(|s| view! {
                                <a href={format!("/tanka/{}", s)}>"next >"</a>
                            })}
                        </div>
                    </nav>
                </div>
            }.into_any()
        }
        None => view! {
            <div class="page">
                <div class="error">"tanka not found"</div>
                <a href="/">"back to index"</a>
            </div>
        }.into_any()
    }
}

#[component]
fn App() -> impl IntoView {
    view! {
        <Router>
            <Routes fallback=|| view! { <div>"404"</div> }>
                <Route path=path!("/") view=IndexPage />
                <Route path=path!("/tanka/:slug") view=TankaPageView />
            </Routes>
        </Router>
    }
}

fn main() {
    console_error_panic_hook::set_once();
    leptos::mount::mount_to_body(App);
}
